# ERPNext Connector - bi-directional

Projekt ID: A3K-30
Unfertige Tasks: 94
Zusammenfassung: Entwicklung einer bidirektionalen Shopify-ERPNext-Integrationsanwendung in sieben technisch definierten Epics, einschließlich Infrastruktur-Setup, API-Integration, Synchronisations-Engine, Webhook-Management und Admin-Interface. Jedes Epic umfasst spezifische technische Beschreibungen, Erfolgskriterien und Implementierungsdetails, um eine zuverlässige und effiziente Integration zwischen den beiden Systemen zu gewährleisten.
Kunde: apps3k (https://www.notion.so/apps3k-291951ec3d8880e88cd5d145156754f9?pvs=21)
Epics: Neues Epic (https://www.notion.so/Neues-Epic-2b8951ec3d888095826bc224854a2649?pvs=21), Epic 1: Projekt-Setup und Grundstruktur (https://www.notion.so/Epic-1-Projekt-Setup-und-Grundstruktur-0ea36393ffd344faab2660e50770ad7c?pvs=21), Epic 2: ERPNext API Client (https://www.notion.so/Epic-2-ERPNext-API-Client-28abc86d98f74b33bb5e5174b5e2f810?pvs=21), Epic 3: Shopify GraphQL Service Layer (https://www.notion.so/Epic-3-Shopify-GraphQL-Service-Layer-7ace64b2dec74f13aef742855396c5f4?pvs=21), Epic 4: Sync-Engine Core (https://www.notion.so/Epic-4-Sync-Engine-Core-db0680e3661e4222801ea0874c3e6bc2?pvs=21), Epic 5: Queue-System mit BullMQ (https://www.notion.so/Epic-5-Queue-System-mit-BullMQ-592b27a130d04b1093dd759fca9c1af7?pvs=21), Epic 6: Webhook-Handler (https://www.notion.so/Epic-6-Webhook-Handler-1d558401cef3467d93871cd8df427499?pvs=21), Epic 7: Admin UI mit Polaris (https://www.notion.so/Epic-7-Admin-UI-mit-Polaris-26944dd32f654f01900415b326aec424?pvs=21), Epic 8: Logging, Audit-Trail und Revert (https://www.notion.so/Epic-8-Logging-Audit-Trail-und-Revert-b407a5c623b34dcbb97ac07c0eeb8e87?pvs=21), Epic 9: Inventory Sync mit Location-Master (https://www.notion.so/Epic-9-Inventory-Sync-mit-Location-Master-3f2de3dd734d4e7084758f4a2a0daa57?pvs=21), Epic 10: Railway Deployment (https://www.notion.so/Epic-10-Railway-Deployment-fe6da4a93ce14c5e9abc751d43b93bf2?pvs=21)
Zeitraum: 17. November 2025 → 17. Dezember 2025
Status: Planung
Verantwortlich: Björn von Känel
Fortschritt: 0
Aufgaben: Shopify Remix App mit npm init @shopify/app initialisieren (https://www.notion.so/Shopify-Remix-App-mit-npm-init-shopify-app-initialisieren-96ba929941604a2889dac4b402ed59f3?pvs=21), Projektstruktur erstellen (routes, services, lib) (https://www.notion.so/Projektstruktur-erstellen-routes-services-lib-d02572b951c14d7fae2fbd5a0cc9ac9b?pvs=21), Prisma Schema mit Datenmodell erstellen (https://www.notion.so/Prisma-Schema-mit-Datenmodell-erstellen-95c0c5842fcf4ca99113fc30d0af245f?pvs=21), PostgreSQL Datenbank einrichten und Prisma-Verbindung konfigurieren (https://www.notion.so/PostgreSQL-Datenbank-einrichten-und-Prisma-Verbindung-konfigurieren-d096fd40da9e49e2b58b7500267b5827?pvs=21), Redis für BullMQ einrichten (https://www.notion.so/Redis-f-r-BullMQ-einrichten-51cb2f2a3b694adf9ba10b9326e3487e?pvs=21), TypeScript Konfiguration mit striktem Type-Checking (https://www.notion.so/TypeScript-Konfiguration-mit-striktem-Type-Checking-aa799c5f556f46d789ecb04c02f18078?pvs=21), shopify.app.toml mit OAuth-Scopes und Webhooks konfigurieren (https://www.notion.so/shopify-app-toml-mit-OAuth-Scopes-und-Webhooks-konfigurieren-07eeea4883bc41ea86825c8cdcd68f0c?pvs=21), Environment Variables Template (.env.example) erstellen (https://www.notion.so/Environment-Variables-Template-env-example-erstellen-566e69c846b744ab8e4081feed8a3ab9?pvs=21), Lokale Entwicklungsumgebung mit ngrok für Webhook-Testing einrichten (https://www.notion.so/Lokale-Entwicklungsumgebung-mit-ngrok-f-r-Webhook-Testing-einrichten-9999fc4b27404ae2a40fac4ada3141c4?pvs=21), Polaris Components für Shopify Admin-Kontext einrichten (https://www.notion.so/Polaris-Components-f-r-Shopify-Admin-Kontext-einrichten-531f5351e4e44807aa2c5fe400434cc5?pvs=21), ERPNext Client Basis-Klasse mit Authentifizierung erstellen (https://www.notion.so/ERPNext-Client-Basis-Klasse-mit-Authentifizierung-erstellen-e719839ad30a4afea884fc99de2f9bb6?pvs=21), Rate Limiting mit Token Bucket implementieren (https://www.notion.so/Rate-Limiting-mit-Token-Bucket-implementieren-a3b5f2b1f5c841788884c8399a56126f?pvs=21), Retry-Logik mit exponential backoff implementieren (https://www.notion.so/Retry-Logik-mit-exponential-backoff-implementieren-8ee75ad214574b36bdf3af20c744a8fb?pvs=21), Typed DocTypes mit Zod Schemas erstellen (Item, Customer, SalesOrder, etc.) (https://www.notion.so/Typed-DocTypes-mit-Zod-Schemas-erstellen-Item-Customer-SalesOrder-etc-d75f2b0c2e164a1db99f780fddecd64b?pvs=21), ERPNext ItemService implementieren (https://www.notion.so/ERPNext-ItemService-implementieren-4e25eb85419a421788c60cc5d5deb101?pvs=21), ERPNext StockService implementieren (https://www.notion.so/ERPNext-StockService-implementieren-0ab2b4e508f9480b943e79181fd0b8a0?pvs=21), ERPNext OrderService implementieren (https://www.notion.so/ERPNext-OrderService-implementieren-60757df475dd4d99837a50385cd87b4d?pvs=21), ERPNext CustomerService implementieren (https://www.notion.so/ERPNext-CustomerService-implementieren-e85f88be16564b5798912044de521a93?pvs=21), ERPNext PriceService implementieren (https://www.notion.so/ERPNext-PriceService-implementieren-82d23f1a9c504cc38f421c4f5676257f?pvs=21), GraphQL-Client und TypeScript Code-Generator einrichten (https://www.notion.so/GraphQL-Client-und-TypeScript-Code-Generator-einrichten-c49d571fae7a4bd79fe34041e69fd0ae?pvs=21), Shopify Products Service implementieren (Queries/Mutations) (https://www.notion.so/Shopify-Products-Service-implementieren-Queries-Mutations-f2ed6336b5b4407b8dd6d7a50a07b6e6?pvs=21), Shopify Inventory Service implementieren (https://www.notion.so/Shopify-Inventory-Service-implementieren-1423b562f48543a79e5136b1eb5e538d?pvs=21), Shopify Orders Service implementieren (https://www.notion.so/Shopify-Orders-Service-implementieren-c471a67b25344d8a9d3b16339179b164?pvs=21), Shopify Customers Service implementieren (https://www.notion.so/Shopify-Customers-Service-implementieren-addd6d8b7cbc4c44ac46fdb26395c010?pvs=21), Shopify Metafields Service implementieren (https://www.notion.so/Shopify-Metafields-Service-implementieren-c494a6870eae4896b464daa1ebd68cbb?pvs=21), Shopify Translations Service implementieren (https://www.notion.so/Shopify-Translations-Service-implementieren-0e1dc0332c4f4c2a975c9b704ded4539?pvs=21), Shopify Bulk Operations Service implementieren (https://www.notion.so/Shopify-Bulk-Operations-Service-implementieren-64ee662451774bd7bcaa3dd667146815?pvs=21), GraphQL Code Generator mit TypeScript einrichten (https://www.notion.so/GraphQL-Code-Generator-mit-TypeScript-einrichten-94b2cec8cb184ce1a9e6b9210233aa08?pvs=21), Rate-Limiting-Strategie für Shopify API implementieren (https://www.notion.so/Rate-Limiting-Strategie-f-r-Shopify-API-implementieren-20440376dcbb4bf4bcf356cc1603b25b?pvs=21), Cursor-basierte Pagination für Listen-Queries implementieren (https://www.notion.so/Cursor-basierte-Pagination-f-r-Listen-Queries-implementieren-4676705fa590475bbb374a7c03d63ae8?pvs=21), SyncEngine Hauptklasse mit Konfiguration erstellen (https://www.notion.so/SyncEngine-Hauptklasse-mit-Konfiguration-erstellen-cf635e1719e149e5a854623bc95e8665?pvs=21), Conflict-Resolver mit Field-Level Detection implementieren (https://www.notion.so/Conflict-Resolver-mit-Field-Level-Detection-implementieren-0025ed74fd674d018d57e955dc602c72?pvs=21), ProductMapper (Shopify Product ↔ ERPNext Item) erstellen (https://www.notion.so/ProductMapper-Shopify-Product-ERPNext-Item-erstellen-3d2c22eca7254536b7d3d8aaa0496aca?pvs=21), VariantMapper (Shopify Variant ↔ ERPNext Item Variante) erstellen (https://www.notion.so/VariantMapper-Shopify-Variant-ERPNext-Item-Variante-erstellen-ffde24aa64bf40a98469c286aee5115b?pvs=21), OrderMapper (Shopify Order → ERPNext Sales Order) erstellen (https://www.notion.so/OrderMapper-Shopify-Order-ERPNext-Sales-Order-erstellen-790b5da6acf24b728b03aabaee599e72?pvs=21), CustomerMapper (Shopify Customer ↔ ERPNext Customer) erstellen (https://www.notion.so/CustomerMapper-Shopify-Customer-ERPNext-Customer-erstellen-3ac273e7b1b04bcf9c7fe914e3c15b4e?pvs=21), InventoryMapper (Shopify InventoryLevel ↔ ERPNext Stock) erstellen (https://www.notion.so/InventoryMapper-Shopify-InventoryLevel-ERPNext-Stock-erstellen-8c80a22ecc0e4d72ac2908cfc0b0e094?pvs=21), Event-Store für Audit-Logs implementieren (https://www.notion.so/Event-Store-f-r-Audit-Logs-implementieren-678b237516964339b47052c917d6aa8b?pvs=21), Snapshot-Manager für Rollback implementieren (https://www.notion.so/Snapshot-Manager-f-r-Rollback-implementieren-385d655b1f0440139649c2c07c93eecf?pvs=21), Sync-Konfiguration pro Entity und Location implementieren (https://www.notion.so/Sync-Konfiguration-pro-Entity-und-Location-implementieren-d3224ac1becb41f5b66433b94dc0e9c1?pvs=21), BullMQ Queue-Definitionen mit Prioritäten erstellen (https://www.notion.so/BullMQ-Queue-Definitionen-mit-Priorit-ten-erstellen-2336727ab0ac4b60b7c0b2c486caf935?pvs=21), Worker Entry Point erstellen (https://www.notion.so/Worker-Entry-Point-erstellen-9a45f623f33448339c9e41bfd6c3b008?pvs=21), productSyncProcessor implementieren (https://www.notion.so/productSyncProcessor-implementieren-b2ac0239e3284bf4bc3db685743004e3?pvs=21), orderSyncProcessor implementieren (https://www.notion.so/orderSyncProcessor-implementieren-9800b5fd581b4d15b4ab810d0eaa3e63?pvs=21), inventorySyncProcessor implementieren (https://www.notion.so/inventorySyncProcessor-implementieren-c68af7631ede45438f3c397fdd331d80?pvs=21), customerSyncProcessor implementieren (https://www.notion.so/customerSyncProcessor-implementieren-ecd2ae45b300489787af43d685d67b45?pvs=21), bulkSyncProcessor implementieren (https://www.notion.so/bulkSyncProcessor-implementieren-0645c980c55a4cb7aaead774ddc6c4eb?pvs=21), Dead Letter Queue für failed Jobs einrichten (https://www.notion.so/Dead-Letter-Queue-f-r-failed-Jobs-einrichten-9dcc9619c27c4bdf8cce23532b0e5734?pvs=21), Rate Limit Handling in Workern implementieren (https://www.notion.so/Rate-Limit-Handling-in-Workern-implementieren-5099faae497146b783bfd9e439f67a1b?pvs=21), Location-Warehouse Mapping Datenmodell erstellen (https://www.notion.so/Location-Warehouse-Mapping-Datenmodell-erstellen-8237e0e631a04ef4a8d1c468df22c390?pvs=21), syncFromShopify für Inventory implementieren (https://www.notion.so/syncFromShopify-f-r-Inventory-implementieren-e5dd3348da2d4801b0c5f6a94d41593b?pvs=21), syncFromERPNext für Inventory implementieren (https://www.notion.so/syncFromERPNext-f-r-Inventory-implementieren-829c75f6370545659159ddf641dcab5c?pvs=21), Location-Config UI mit Master-Auswahl erstellen (https://www.notion.so/Location-Config-UI-mit-Master-Auswahl-erstellen-bfc56acd6bba49e59dfdf9a245eba7bc?pvs=21), Conflict Handling bei bidirektionalem Inventory Sync (https://www.notion.so/Conflict-Handling-bei-bidirektionalem-Inventory-Sync-cf674820e1e14400ab930778a9d777ce?pvs=21), Bestandsvergleichs-View erstellen (https://www.notion.so/Bestandsvergleichs-View-erstellen-eecdf27dd19849dd92c6c38d0f0ebb2c?pvs=21), Manual Inventory Sync Trigger implementieren (https://www.notion.so/Manual-Inventory-Sync-Trigger-implementieren-ddda0c11d91a4621a5ce2e87868dfa6b?pvs=21), Dashboard-Seite mit Sync-Status-Übersicht erstellen (https://www.notion.so/Dashboard-Seite-mit-Sync-Status-bersicht-erstellen-aa63beaadbf649c081e2fe47dc1a40b9?pvs=21), Settings-Seite für ERPNext-Verbindung erstellen (https://www.notion.so/Settings-Seite-f-r-ERPNext-Verbindung-erstellen-4c3473c70a054858b143e1196f00ba3a?pvs=21), Sync-Konfiguration UI pro Entity-Typ erstellen (https://www.notion.so/Sync-Konfiguration-UI-pro-Entity-Typ-erstellen-58c6b5c461eb484585c5cc7c48b0c0e4?pvs=21), Entity-Mappings-Seite mit IndexTable erstellen (https://www.notion.so/Entity-Mappings-Seite-mit-IndexTable-erstellen-e9cfc8c170474a039f5dc3b996b450f9?pvs=21), Logs-Seite mit Filter und Pagination erstellen (https://www.notion.so/Logs-Seite-mit-Filter-und-Pagination-erstellen-acb1e1a018d740d3903036db4b2f5173?pvs=21), Inventory-Seite mit Location-Übersicht erstellen (https://www.notion.so/Inventory-Seite-mit-Location-bersicht-erstellen-8fb54684d89e479aa377c20054992d06?pvs=21), Navigation mit NavMenu implementieren (https://www.notion.so/Navigation-mit-NavMenu-implementieren-78aeb2416d544fb5a42b34276acf9dfa?pvs=21), ERPNext Verbindungstest-Funktionalität implementieren (https://www.notion.so/ERPNext-Verbindungstest-Funktionalit-t-implementieren-4e46eb6588654e3ebefeb97b05ba0dc8?pvs=21), Field-Mapping UI mit ResourceList erstellen (https://www.notion.so/Field-Mapping-UI-mit-ResourceList-erstellen-6cc1ae0938984b9f8087632cacd8140c?pvs=21), Metafield-Mapping Konfiguration UI erstellen (https://www.notion.so/Metafield-Mapping-Konfiguration-UI-erstellen-d7c129271b694900878a9fa8f77707fa?pvs=21), Products Webhook-Handler erstellen (create/update/delete) (https://www.notion.so/Products-Webhook-Handler-erstellen-create-update-delete-eeab3483f3d847dcbfbec7c0a9bfd7f5?pvs=21), Orders Webhook-Handler erstellen (create/updated/paid/fulfilled) (https://www.notion.so/Orders-Webhook-Handler-erstellen-create-updated-paid-fulfilled-452e268b4e0b412789ff240571289a11?pvs=21), Customers Webhook-Handler erstellen (create/update) (https://www.notion.so/Customers-Webhook-Handler-erstellen-create-update-d7f83c28a66f482487b27b95d84e01a3?pvs=21), Inventory Webhook-Handler erstellen (levels/update) (https://www.notion.so/Inventory-Webhook-Handler-erstellen-levels-update-cae70577128744a394b5e8a7f1e0b454?pvs=21), HMAC-Validierung für Shopify Webhooks implementieren (https://www.notion.so/HMAC-Validierung-f-r-Shopify-Webhooks-implementieren-aba92f2dbea54730a74a04ca4a1a08bc?pvs=21), ERPNext Webhook-Signatur-Validierung implementieren (https://www.notion.so/ERPNext-Webhook-Signatur-Validierung-implementieren-f4340298a94048ae92f28a3afbf93085?pvs=21), Idempotenz-Check für Webhook-Verarbeitung implementieren (https://www.notion.so/Idempotenz-Check-f-r-Webhook-Verarbeitung-implementieren-f3c4e8d0860e4ddd9b2bf7cc4a11e623?pvs=21), processed_webhooks Tabelle und Logik erstellen (https://www.notion.so/processed_webhooks-Tabelle-und-Logik-erstellen-9354e4d52fe2459ca990e798614af05a?pvs=21), app/uninstalled Webhook-Handler erstellen (https://www.notion.so/app-uninstalled-Webhook-Handler-erstellen-745723fda1ba468b851040eadf396aae?pvs=21), SyncLog und SyncSession Prisma Models erstellen (https://www.notion.so/SyncLog-und-SyncSession-Prisma-Models-erstellen-5fa9ed3e99ce4cfeb8fdb1cab7879886?pvs=21), Pino Logging mit JSON-Format einrichten (https://www.notion.so/Pino-Logging-mit-JSON-Format-einrichten-cafa5a1d0b7f4d57a478f6e2bb8f6f70?pvs=21), Pre-Sync Snapshot-Erstellung implementieren (https://www.notion.so/Pre-Sync-Snapshot-Erstellung-implementieren-4a6aec76c1904354984a0ca22d1fd60c?pvs=21), RollbackManager Klasse implementieren (https://www.notion.so/RollbackManager-Klasse-implementieren-d1468b0e79184aa596164a70b5d29ee4?pvs=21), Session-Rollback Funktionalität implementieren (https://www.notion.so/Session-Rollback-Funktionalit-t-implementieren-c9d76b7b73434f4ea6fb336f6843b554?pvs=21), Rollback UI mit Confirmation Modal erstellen (https://www.notion.so/Rollback-UI-mit-Confirmation-Modal-erstellen-2ef8c5cd45b14d70843fa2c0b4364fa9?pvs=21), Automatisches Rollback bei kritischen Fehlern implementieren (https://www.notion.so/Automatisches-Rollback-bei-kritischen-Fehlern-implementieren-ad9b5583ef014fcc98ef5c056f2452c5?pvs=21), Snapshot-Cleanup Cron Job einrichten (https://www.notion.so/Snapshot-Cleanup-Cron-Job-einrichten-dbc1d58a6536416ba7ae719f77fd1fec?pvs=21), Log-Export als CSV/JSON implementieren (https://www.notion.so/Log-Export-als-CSV-JSON-implementieren-9113db90e7b843a7a50c9da153c42368?pvs=21), railway.json für Web Service konfigurieren (https://www.notion.so/railway-json-f-r-Web-Service-konfigurieren-3b8b9d77a977434ab78df720c42463da?pvs=21), railway.json für Worker Service konfigurieren (https://www.notion.so/railway-json-f-r-Worker-Service-konfigurieren-9173cb504d5e4777b278ef71cfddab5f?pvs=21), package.json Scripts für Deployment konfigurieren (https://www.notion.so/package-json-Scripts-f-r-Deployment-konfigurieren-d4ec91448e0f413b9a576acb17a83898?pvs=21), Environment Variables in Railway Dashboard einrichten (https://www.notion.so/Environment-Variables-in-Railway-Dashboard-einrichten-084f2ae6f7754e21874a4453f0dde24f?pvs=21), Health Check Endpoint (/api/health) erstellen (https://www.notion.so/Health-Check-Endpoint-api-health-erstellen-f84e93790e3b4076b43646898c24592b?pvs=21), PostgreSQL und Redis Services in Railway provisionieren (https://www.notion.so/PostgreSQL-und-Redis-Services-in-Railway-provisionieren-3ddc052e30684b048401b9d662a4eea8?pvs=21), GitHub Actions für CI/CD Pipeline einrichten (https://www.notion.so/GitHub-Actions-f-r-CI-CD-Pipeline-einrichten-462dd8cd8814406c9fc528587b5f2304?pvs=21), Sentry für Error Tracking einrichten (https://www.notion.so/Sentry-f-r-Error-Tracking-einrichten-ec58a5e56e454e0a8b96ec2a9a5d080f?pvs=21), Bull Board für Queue Monitoring einrichten (https://www.notion.so/Bull-Board-f-r-Queue-Monitoring-einrichten-eeaaa8d5e0e9493781ba3203c4179c3c?pvs=21), Staging und Production Environments konfigurieren (https://www.notion.so/Staging-und-Production-Environments-konfigurieren-97333a71c2c84fc1a391cf1ed329d734?pvs=21)
Clockify Time Report: ⏱️ View open time logs
Cursor: No
DevDocs: ERPNext ←→ Shopify Sync: Technische Definition (https://www.notion.so/ERPNext-Shopify-Sync-Technische-Definition-2b8951ec3d8881e4849dd3704a94a788?pvs=21)

## Projektplan: Shopify-ERPNext Integration App

## Übersicht

Der folgende Projektplan strukturiert die Entwicklung einer bidirektionalen Shopify-ERPNext-Integrationsanwendung in sieben technisch präzise definierte Epics. Jedes Epic basiert auf den offiziellen Dokumentationen der beteiligten Systeme und Plattformen und ist so konzipiert, dass es mit AI-gestützten Entwicklungswerkzeugen wie Cursor AI effizient umgesetzt werden kann. Die technischen Spezifikationen referenzieren explizit die relevanten Dokumentationsquellen, um Mehrdeutigkeiten zu vermeiden und eine verlässliche Implementierung zu gewährleisten.

---

## Epic 1: Projekt-Foundation und Infrastruktur-Setup

### Technische Beschreibung

Dieses Epic etabliert die technologische Grundlage der Anwendung basierend auf dem Shopify Remix App Template, das unter [https://shopify.dev/docs/apps/build/scaffold-app](https://shopify.dev/docs/apps/build/scaffold-app) dokumentiert ist. Die Implementierung folgt den Shopify App Development Standards für embedded Apps, wie sie unter [https://shopify.dev/docs/apps/build/authentication-authorization](https://shopify.dev/docs/apps/build/authentication-authorization) und [https://shopify.dev/docs/apps/auth/oauth](https://shopify.dev/docs/apps/auth/oauth) spezifiziert sind.

Das Datenbankschema wird mit Prisma ORM Version 5.x erstellt, dessen Schema-Definition unter [https://www.prisma.io/docs/concepts/components/prisma-schema](https://www.prisma.io/docs/concepts/components/prisma-schema) dokumentiert ist. Die Datenbankverbindung erfolgt zu PostgreSQL Version 14 oder höher, wobei die Prisma-PostgreSQL-Connector-Spezifikation unter [https://www.prisma.io/docs/concepts/database-connectors/postgresql](https://www.prisma.io/docs/concepts/database-connectors/postgresql) zu beachten ist.

Die Job-Queue-Infrastruktur nutzt BullMQ Version 4.x mit Redis Version 7.x als Backing Store. Die Queue-Konfiguration folgt den Best Practices unter [https://docs.bullmq.io/guide/queues](https://docs.bullmq.io/guide/queues) und [https://docs.bullmq.io/guide/workers](https://docs.bullmq.io/guide/workers). Die TypeScript-Konfiguration orientiert sich an den Shopify App-Empfehlungen unter [https://shopify.dev/docs/apps/tools/cli/typescript](https://shopify.dev/docs/apps/tools/cli/typescript).

Die Deployment-Konfiguration für Railway folgt der Dokumentation unter [https://docs.railway.app/deploy/deployments](https://docs.railway.app/deploy/deployments) und [https://docs.railway.app/deploy/integrations](https://docs.railway.app/deploy/integrations). Die GitHub Actions Workflows werden gemäß [https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider](https://docs.github.com/en/actions/deployment/deploying-to-your-cloud-provider) konfiguriert, mit spezifischen Railway-Deploy-Actions wie unter [https://github.com/marketplace/actions/deploy-to-railway](https://github.com/marketplace/actions/deploy-to-railway) dokumentiert.

Die Entwicklungsumgebung nutzt ngrok für lokales Webhook-Testing, wie unter [https://shopify.dev/docs/apps/build/test-your-app](https://shopify.dev/docs/apps/build/test-your-app) beschrieben. Die lokale Shopify CLI-Konfiguration folgt [https://shopify.dev/docs/apps/tools/cli/commands](https://shopify.dev/docs/apps/tools/cli/commands).

### Erfolgskriterien

Die erfolgreiche Umsetzung dieses Epics manifestiert sich in einer funktionsfähigen Shopify Remix App, die erfolgreich OAuth-Authentifizierung mit Shopify durchführt und Session-Tokens gemäß [https://shopify.dev/docs/apps/auth/oauth/session-tokens](https://shopify.dev/docs/apps/auth/oauth/session-tokens) verwaltet. Das Prisma-Schema ist vollständig migriert und die Datenbankverbindung zu PostgreSQL erfolgreich etabliert. BullMQ verarbeitet Test-Jobs zuverlässig mit Redis als Backend. Die TypeScript-Kompilierung erfolgt fehlerfrei mit strikten Type-Checking-Einstellungen.

Die lokale Entwicklungsumgebung empfängt Shopify-Webhooks über ngrok. Railway ist mit separaten Staging- und Production-Environments konfiguriert, jeweils mit eigenen PostgreSQL- und Redis-Instanzen. GitHub Actions deployen automatisch bei Commits auf den main-Branch nach Staging und bei Tags nach Production. Die Polaris-Komponenten rendern korrekt im Shopify Admin-Kontext gemäß [https://polaris.shopify.com/components](https://polaris.shopify.com/components).

---

## Epic 2: ERPNext-Verbindungsmodul und API-Integration

### Technische Beschreibung

Dieses Epic implementiert die vollständige Anbindung an ERPNext Version 15, wobei sowohl die REST API als auch die GraphQL API genutzt werden. Die ERPNext REST API ist unter [https://frappeframework.com/docs/user/en/api](https://frappeframework.com/docs/user/en/api) dokumentiert, mit spezifischen Endpunkten für Ressourcenverwaltung unter [https://frappeframework.com/docs/user/en/api/rest](https://frappeframework.com/docs/user/en/api/rest). Die ERPNext GraphQL API Version 15 folgt der Spezifikation unter [https://github.com/frappe/frappe/blob/version-15/frappe/graphql/README.md](https://github.com/frappe/frappe/blob/version-15/frappe/graphql/README.md).

Die Authentifizierung erfolgt über API-Keys und API-Secrets gemäß [https://frappeframework.com/docs/user/en/api/rest#authentication](https://frappeframework.com/docs/user/en/api/rest#authentication). Für erhöhte Sicherheit wird zusätzlich OAuth 2.0 unterstützt, wie unter [https://frappeframework.com/docs/user/en/api/oauth](https://frappeframework.com/docs/user/en/api/oauth) dokumentiert. Die Implementierung berücksichtigt die Rate-Limiting-Vorgaben von ERPNext, die in [https://frappeframework.com/docs/user/en/api/rest#rate-limiting](https://frappeframework.com/docs/user/en/api/rest#rate-limiting) spezifiziert sind.

Das Verbindungsmodul implementiert einen Type-Safe API-Client mit TypeScript-Interfaces, die aus den ERPNext DocType-Definitionen generiert werden. Die relevanten DocTypes sind unter [https://docs.erpnext.com/docs/user/manual/en](https://docs.erpnext.com/docs/user/manual/en) dokumentiert, insbesondere Item unter [https://docs.erpnext.com/docs/user/manual/en/stock/item](https://docs.erpnext.com/docs/user/manual/en/stock/item), Customer unter [https://docs.erpnext.com/docs/user/manual/en/CRM/customer](https://docs.erpnext.com/docs/user/manual/en/CRM/customer), Sales Order unter [https://docs.erpnext.com/docs/user/manual/en/selling/sales-order](https://docs.erpnext.com/docs/user/manual/en/selling/sales-order), Delivery Note unter [https://docs.erpnext.com/docs/user/manual/en/stock/delivery-note](https://docs.erpnext.com/docs/user/manual/en/stock/delivery-note), Sales Invoice unter [https://docs.erpnext.com/docs/user/manual/en/accounts/sales-invoice](https://docs.erpnext.com/docs/user/manual/en/accounts/sales-invoice) und Payment Entry unter [https://docs.erpnext.com/docs/user/manual/en/accounts/payment-entry](https://docs.erpnext.com/docs/user/manual/en/accounts/payment-entry).

Die Fehlerbehandlung folgt den ERPNext-spezifischen HTTP-Statuscodes und Error-Responses, wie sie unter [https://frappeframework.com/docs/user/en/api/rest#error-handling](https://frappeframework.com/docs/user/en/api/rest#error-handling) definiert sind. Die Implementierung umfasst Retry-Logik mit exponentieller Backoff-Strategie für transiente Fehler gemäß Best Practices.

Die GraphQL-Queries und Mutations werden gemäß dem ERPNext GraphQL-Schema definiert, das über Introspection abgerufen werden kann. Die Implementierung nutzt einen GraphQL-Client wie Apollo Client oder URQL mit TypeScript-Code-Generation über GraphQL Code Generator gemäß [https://the-guild.dev/graphql/codegen/docs/getting-started](https://the-guild.dev/graphql/codegen/docs/getting-started).

### Erfolgskriterien

Das ERPNext-Verbindungsmodul authentifiziert sich erfolgreich mit API-Key und API-Secret sowie optional über OAuth 2.0. Der API-Client führt CRUD-Operationen auf alle relevanten ERPNext DocTypes fehlerfrei aus, einschließlich Item, Customer, Sales Order, Delivery Note, Sales Invoice, Payment Entry, Credit Note und Stock Entry. Die TypeScript-Interfaces reflektieren präzise die ERPNext DocType-Strukturen mit vollständiger Type-Safety.

GraphQL-Queries und Mutations funktionieren zuverlässig für alle unterstützten DocTypes. Die Fehlerbehandlung unterscheidet korrekt zwischen verschiedenen Fehlertypen wie Authentifizierungsfehlern, Validierungsfehlern, Netzwerkfehlern und Rate-Limiting-Responses. Die Retry-Logik respektiert Rate-Limits und vermeidet API-Überlastung. Connection-Pooling und Request-Batching optimieren die API-Nutzung gemäß den Empfehlungen in der ERPNext-Dokumentation.

---

## Epic 3: Shopify GraphQL Admin API Integration

### Technische Beschreibung

Dieses Epic implementiert die vollständige Integration mit der Shopify GraphQL Admin API Version 2024-10 oder neuerer, wie sie unter [https://shopify.dev/docs/api/admin-graphql](https://shopify.dev/docs/api/admin-graphql) dokumentiert ist. Die API-Versionierung folgt [https://shopify.dev/docs/api/usage/versioning](https://shopify.dev/docs/api/usage/versioning), wobei die Anwendung die aktuellste stabile Version nutzt und automatisch auf Deprecations reagiert.

Die Implementierung umfasst alle relevanten GraphQL-Queries und Mutations für Products gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/Product](https://shopify.dev/docs/api/admin-graphql/latest/objects/Product) und [https://shopify.dev/docs/api/admin-graphql/latest/mutations/productCreate](https://shopify.dev/docs/api/admin-graphql/latest/mutations/productCreate), für Variants gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/ProductVariant](https://shopify.dev/docs/api/admin-graphql/latest/objects/ProductVariant), für Customers gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/Customer](https://shopify.dev/docs/api/admin-graphql/latest/objects/Customer), für Orders gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/Order](https://shopify.dev/docs/api/admin-graphql/latest/objects/Order), für Fulfillments gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/Fulfillment](https://shopify.dev/docs/api/admin-graphql/latest/objects/Fulfillment) und für Inventory gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/InventoryLevel](https://shopify.dev/docs/api/admin-graphql/latest/objects/InventoryLevel).

Die Metafields-Verwaltung folgt der Spezifikation unter [https://shopify.dev/docs/api/admin-graphql/latest/objects/Metafield](https://shopify.dev/docs/api/admin-graphql/latest/objects/Metafield) und [https://shopify.dev/docs/apps/build/custom-data/metafields](https://shopify.dev/docs/apps/build/custom-data/metafields), mit Definition von Metafield-Definitionen über [https://shopify.dev/docs/api/admin-graphql/latest/mutations/metafieldDefinitionCreate](https://shopify.dev/docs/api/admin-graphql/latest/mutations/metafieldDefinitionCreate). Die Implementierung nutzt Bulk Operations für große Datenmengen gemäß [https://shopify.dev/docs/api/usage/bulk-operations/queries](https://shopify.dev/docs/api/usage/bulk-operations/queries) und [https://shopify.dev/docs/api/usage/bulk-operations/mutations](https://shopify.dev/docs/api/usage/bulk-operations/mutations).

Die Rate-Limiting-Strategie implementiert die Shopify API Rate Limits gemäß [https://shopify.dev/docs/api/usage/rate-limits](https://shopify.dev/docs/api/usage/rate-limits), einschließlich Cost-Based Rate Limiting mit Calculated Query Costs. Die Implementierung überwacht die X-Shopify-Shop-Api-Call-Limit und Retry-After Headers und passt die Request-Rate dynamisch an.

Der GraphQL-Client nutzt TypeScript-Code-Generation über GraphQL Code Generator mit dem @graphql-codegen/typescript-graphql-request Plugin gemäß [https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-graphql-request](https://the-guild.dev/graphql/codegen/plugins/typescript/typescript-graphql-request). Die generated Types werden automatisch bei Schema-Änderungen aktualisiert.

Die Webhook-Registrierung erfolgt über die GraphQL API mittels webhookSubscriptionCreate Mutation gemäß [https://shopify.dev/docs/api/admin-graphql/latest/mutations/webhookSubscriptionCreate](https://shopify.dev/docs/api/admin-graphql/latest/mutations/webhookSubscriptionCreate). Die Webhook-Topics folgen [https://shopify.dev/docs/api/webhooks](https://shopify.dev/docs/api/webhooks) und umfassen products/create, products/update, products/delete, orders/create, orders/updated, orders/paid, orders/fulfilled, orders/cancelled, customers/create, customers/update, inventory_levels/update, fulfillments/create und fulfillments/update.

### Erfolgskriterien

Die Shopify GraphQL Admin API-Integration führt alle CRUD-Operationen auf Products, Variants, Customers, Orders, Fulfillments und Inventory Levels erfolgreich aus. Die TypeScript-Interfaces sind vollständig aus dem Shopify GraphQL Schema generiert mit vollständiger Type-Safety. Bulk Operations verarbeiten große Produktkataloge effizient ohne Timeout-Fehler.

Metafields werden korrekt erstellt, gelesen, aktualisiert und gelöscht, mit Unterstützung aller Metafield-Typen gemäß Shopify-Spezifikation. Die Rate-Limiting-Implementierung hält die API-Call-Limits ein und nutzt Request-Throttling zur Vermeidung von 429-Responses. Webhooks sind korrekt registriert für alle relevanten Topics und werden bei Datenänderungen zuverlässig ausgelöst.

Die GraphQL-Queries sind optimiert mit präziser Feld-Selektion zur Minimierung der Query Costs. Die Implementierung nutzt GraphQL Fragments für wiederverwendbare Query-Teile gemäß [https://shopify.dev/docs/api/usage/pagination#use-fragments](https://shopify.dev/docs/api/usage/pagination#use-fragments). Cursor-basierte Pagination funktioniert fehlerfrei für alle Listen-Queries gemäß [https://shopify.dev/docs/api/usage/pagination](https://shopify.dev/docs/api/usage/pagination).

---

## Epic 4: Bidirektionale Sync-Engine mit granularer Konfiguration

### Technische Beschreibung

Dieses Epic implementiert die zentrale Synchronisations-Engine, die bidirektionale Datenflüsse zwischen Shopify und ERPNext orchestriert. Die Architektur folgt einem Event-Driven-Pattern mit BullMQ als Job-Queue gemäß [https://docs.bullmq.io/patterns/process](https://docs.bullmq.io/patterns/process). Die Implementierung nutzt Named Queues für verschiedene Entitätstypen mit unterschiedlichen Prioritäten und Concurrency-Einstellungen.

Die Sync-Konfiguration wird in der PostgreSQL-Datenbank persistiert mit einem Prisma-Schema, das granulare Einstellungen pro Entitätstyp ermöglicht. Das Schema umfasst Felder für syncEnabled als Boolean, syncDirection als Enum mit Werten SHOPIFY_TO_ERPNEXT, ERPNEXT_TO_SHOPIFY und BIDIRECTIONAL, fieldMappings als JSONB-Feld mit Mapping-Definitionen, transformationRules als JSONB für Custom-Transformationen und conflictResolution als Enum mit Werten SHOPIFY_WINS, ERPNEXT_WINS und MANUAL_REVIEW.

Die Product-Synchronisation implementiert die vollständige Mapping-Logik zwischen Shopify Products mit Variants und ERPNext Items mit Item Variants gemäß [https://docs.erpnext.com/docs/user/manual/en/stock/item-variants](https://docs.erpnext.com/docs/user/manual/en/stock/item-variants). Die Implementierung berücksichtigt Shopify Product Options gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/ProductOption](https://shopify.dev/docs/api/admin-graphql/latest/objects/ProductOption) und mappt diese auf ERPNext Item Attribute gemäß [https://docs.erpnext.com/docs/user/manual/en/stock/item-attribute](https://docs.erpnext.com/docs/user/manual/en/stock/item-attribute).

Die Customer-Synchronisation mappt Shopify Customers auf ERPNext Customers mit zugehörigen Address- und Contact-DocTypes. Die Implementierung folgt den ERPNext Customer-Strukturen unter [https://docs.erpnext.com/docs/user/manual/en/CRM/customer](https://docs.erpnext.com/docs/user/manual/en/CRM/customer) und berücksichtigt Customer Groups sowie Customer Territories.

Die Order-Synchronisation konvertiert Shopify Orders in ERPNext Sales Orders unter Beachtung aller Line Items, Discounts, Taxes und Shipping Charges. Die Implementierung folgt der Sales Order-Struktur unter [https://docs.erpnext.com/docs/user/manual/en/selling/sales-order](https://docs.erpnext.com/docs/user/manual/en/selling/sales-order) und erstellt zugehörige Delivery Notes bei Fulfillments gemäß [https://docs.erpnext.com/docs/user/manual/en/stock/delivery-note](https://docs.erpnext.com/docs/user/manual/en/stock/delivery-note) sowie Sales Invoices bei Payment gemäß [https://docs.erpnext.com/docs/user/manual/en/accounts/sales-invoice](https://docs.erpnext.com/docs/user/manual/en/accounts/sales-invoice).

Die Fulfillment-Synchronisation implementiert bidirektionale Updates zwischen Shopify Fulfillments und ERPNext Delivery Notes mit Tracking-Informationen. Die Implementierung nutzt Shopify FulfillmentInput gemäß [https://shopify.dev/docs/api/admin-graphql/latest/mutations/fulfillmentCreate](https://shopify.dev/docs/api/admin-graphql/latest/mutations/fulfillmentCreate) und mappt auf ERPNext Delivery Note Items.

Die Discount-Synchronisation mappt Shopify Price Rules gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/PriceRule](https://shopify.dev/docs/api/admin-graphql/latest/objects/PriceRule) auf ERPNext Pricing Rules gemäß [https://docs.erpnext.com/docs/user/manual/en/accounts/pricing-rule](https://docs.erpnext.com/docs/user/manual/en/accounts/pricing-rule). Die Implementierung berücksichtigt verschiedene Discount-Typen wie Percentage, Fixed Amount und Buy X Get Y.

Die Metafield-Synchronisation implementiert flexibles Mapping zwischen Shopify Metafields und ERPNext Custom Fields. Die Implementierung folgt [https://shopify.dev/docs/apps/build/custom-data/metafields/manage](https://shopify.dev/docs/apps/build/custom-data/metafields/manage) für Shopify-seitige Operationen und [https://frappeframework.com/docs/user/en/custom-fields](https://frappeframework.com/docs/user/en/custom-fields) für ERPNext Custom Field Management. Das Mapping-Schema unterstützt Type-Conversion zwischen verschiedenen Datentypen wie String, Integer, JSON, Date und Boolean.

Die Inventory-Synchronisation implementiert pro Location-Warehouse-Mapping individuelle Sync-Richtungen. Die Konfiguration erfolgt über ein InventoryLocationMapping-Schema mit Feldern für shopifyLocationId, erpnextWarehouse, syncDirection, updateFrequency und conflictResolution. Die Implementierung nutzt Shopify inventoryAdjustQuantities Mutation gemäß [https://shopify.dev/docs/api/admin-graphql/latest/mutations/inventoryAdjustQuantities](https://shopify.dev/docs/api/admin-graphql/latest/mutations/inventoryAdjustQuantities) und ERPNext Stock Entry gemäß [https://docs.erpnext.com/docs/user/manual/en/stock/stock-entry](https://docs.erpnext.com/docs/user/manual/en/stock/stock-entry).

Die Transformation-Engine implementiert ein Plugin-System für Custom-Transformationen mit TypeScript-Interface-Definitionen. Die Transformers werden als Pure Functions implementiert mit Input-Validation und Output-Validation über Zod-Schemas gemäß [https://zod.dev](https://zod.dev/).

### Erfolgskriterien

Die Sync-Engine verarbeitet alle Entitätstypen bidirektional gemäß konfigurierter Sync-Richtung. Die granulare Konfiguration ermöglicht pro Entitätstyp individuelle Sync-Einstellungen mit Field-Level-Mapping. Die Product-Synchronisation erstellt korrekt ERPNext Items mit allen Variants und umgekehrt Shopify Products mit allen Options und Variants.

Die Customer-Synchronisation erstellt vollständige Customer-Records mit Addresses und Contacts in beiden Systemen. Die Order-Synchronisation konvertiert Shopify Orders in Sales Orders mit korrekten Line Items, Pricing, Taxes und Shipping Charges. Fulfillments werden bidirektional synchronisiert mit korrekten Tracking-Informationen.

Die Inventory-Synchronisation respektiert pro Location-Warehouse-Mapping die konfigurierte Sync-Richtung und verhindert Konflikte durch definierte Resolution-Strategien. Discounts werden korrekt als Pricing Rules in ERPNext abgebildet mit allen Bedingungen und Limits. Metafields werden flexibel zwischen Systemen synchronisiert mit Type-Conversion und Validation.

Die Transformation-Engine führt Custom-Transformationen fehlerfrei aus mit vollständiger Error-Handling. Die Job-Queue verarbeitet Sync-Jobs mit konfigurierbarer Concurrency und Priorität. Failed Jobs werden automatisch mit Retry-Logik verarbeitet gemäß BullMQ-Best-Practices unter [https://docs.bullmq.io/guide/retrying-failing-jobs](https://docs.bullmq.io/guide/retrying-failing-jobs).

---

## Epic 5: Webhook-Management und Event-Processing

### Technische Beschreibung

Dieses Epic implementiert das vollständige Webhook-Management für bidirektionale Event-Verarbeitung zwischen Shopify und ERPNext. Die Shopify-Webhook-Implementierung folgt [https://shopify.dev/docs/apps/build/webhooks](https://shopify.dev/docs/apps/build/webhooks) mit HMAC-Verification gemäß [https://shopify.dev/docs/apps/build/webhooks/subscribe/https#step-5-verify-the-webhook](https://shopify.dev/docs/apps/build/webhooks/subscribe/https#step-5-verify-the-webhook).

Die Webhook-Endpunkte werden als Express-Routes implementiert mit Middleware für HMAC-Verification, Request-Validation und Idempotency-Checks. Die Implementierung nutzt crypto.createHmac für HMAC-Verification mit dem Shopify Webhook Secret. Die Webhook-Payloads werden gegen JSON-Schemas validiert mit Ajv gemäß [https://ajv.js.org](https://ajv.js.org/).

Die ERPNext-Webhook-Konfiguration erfolgt über die DocType Webhook gemäß [https://frappeframework.com/docs/user/en/webhooks](https://frappeframework.com/docs/user/en/webhooks). Die Webhooks werden programmatisch erstellt mit POST-Requests zur ERPNext API mit Webhook-Definitionen für alle relevanten DocTypes. Die Webhook-URL zeigt auf den App-Endpunkt mit Authentication über ein Shared Secret.

Die Event-Processing-Pipeline nutzt BullMQ für asynchrone Verarbeitung mit Named Queues für verschiedene Event-Types. Die Implementierung folgt dem Priority Queue Pattern unter [https://docs.bullmq.io/guide/jobs/prioritized](https://docs.bullmq.io/guide/jobs/prioritized) mit höherer Priorität für Payment- und Fulfillment-Events. Die Job-Definitionen umfassen Type-Safe Payloads mit vollständiger TypeScript-Interface-Definition.

Die Idempotency-Implementierung nutzt Redis für Duplicate-Detection mit einer TTL-basierten Strategie. Jeder Webhook erhält eine eindeutige ID basierend auf Event-Type, Entity-ID und Timestamp, die für eine konfigurierbare Dauer in Redis gespeichert wird. Die Implementierung folgt dem Pattern unter [https://docs.bullmq.io/patterns/idempotent-jobs](https://docs.bullmq.io/patterns/idempotent-jobs).

Die Webhook-Registration erfolgt automatisch beim App-Install über die Shopify webhookSubscriptionCreate Mutation. Die Implementierung prüft existierende Webhook-Subscriptions über webhookSubscriptions Query gemäß [https://shopify.dev/docs/api/admin-graphql/latest/queries/webhookSubscriptions](https://shopify.dev/docs/api/admin-graphql/latest/queries/webhookSubscriptions) und erstellt fehlende Subscriptions. Die Webhook-URLs werden dynamisch basierend auf der App-URL konstruiert.

Die Error-Handling-Strategie implementiert unterschiedliche Retry-Policies basierend auf Fehler-Type. Transiente Fehler wie Network-Timeouts werden mit exponentieller Backoff-Strategie wiederholt gemäß [https://docs.bullmq.io/guide/retrying-failing-jobs#custom-backoff-strategy](https://docs.bullmq.io/guide/retrying-failing-jobs#custom-backoff-strategy). Permanente Fehler wie Validation-Errors werden nach konfigurierbaren Attempts in eine Dead Letter Queue verschoben gemäß [https://docs.bullmq.io/patterns/failing-fast](https://docs.bullmq.io/patterns/failing-fast).

Die Webhook-Delivery-Monitoring implementiert Health-Checks für Webhook-Endpunkte mit automatischer Re-Registration bei Delivery-Failures. Die Implementierung nutzt Shopify Webhook-Metrics über die webhookSubscriptions Query mit deliveryStats-Feld gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/WebhookSubscription](https://shopify.dev/docs/api/admin-graphql/latest/objects/WebhookSubscription).

### Erfolgskriterien

Die Shopify-Webhooks werden erfolgreich empfangen mit HMAC-Verification für alle registrierten Topics. Die ERPNext-Webhooks werden korrekt konfiguriert und lösen bei DocType-Änderungen zuverlässig aus. Die Webhook-Payloads werden gegen JSON-Schemas validiert und fehlerhafte Payloads abgelehnt.

Die Idempotency-Checks verhindern Duplicate-Processing von wiederholten Webhook-Deliveries. Die Event-Processing-Pipeline verarbeitet Webhooks asynchron über BullMQ mit konfigurierbarer Concurrency. Die Priority-Queues priorisieren zeitkritische Events wie Payments und Fulfillments.

Die Retry-Logik unterscheidet zwischen transienten und permanenten Fehlern mit angemessenen Retry-Strategien. Failed Jobs werden nach konfigurierbaren Attempts in eine Dead Letter Queue verschoben für manuelle Review. Die Webhook-Registration erfolgt automatisch beim App-Install und hält sich über App-Lifecycle.

Die Webhook-Delivery-Monitoring erkennt fehlgeschlagene Deliveries und re-registriert Webhooks automatisch bei Bedarf. Die Webhook-Endpunkte antworten innerhalb der Shopify-Timeout-Limits von fünf Sekunden gemäß [https://shopify.dev/docs/apps/build/webhooks/subscribe/https#response-requirements](https://shopify.dev/docs/apps/build/webhooks/subscribe/https#response-requirements). Die Event-Processing-Logs ermöglichen vollständiges Tracing von Webhook-Events durch die gesamte Pipeline.

---

## Epic 6: Logging, Audit-Trail und Revert-Funktionalität

### Technische Beschreibung

Dieses Epic implementiert ein umfassendes Logging- und Audit-System mit Revert-Funktionalität für fehlerhafte Synchronisationen. Die Logging-Architektur nutzt strukturiertes Logging mit Pino gemäß [https://getpino.io](https://getpino.io/) mit JSON-Format für maschinelle Verarbeitbarkeit. Die Log-Levels folgen der Standard-Hierarchie mit trace, debug, info, warn, error und fatal.

Das Audit-Trail-Schema wird als Prisma-Model SyncLog definiert mit Feldern für id als UUID, timestamp als DateTime, entityType als Enum mit Werten PRODUCT, CUSTOMER, ORDER, FULFILLMENT, INVENTORY, DISCOUNT, entityId als String für die externe Entity-ID, syncDirection als Enum, status als Enum mit Werten SUCCESS, FAILED, PENDING, REVERTED, sourceSnapshot als JSONB für vollständigen Daten-Snapshot vor Sync, targetSnapshot als JSONB für Daten-Snapshot nach Sync, errorMessage als Text für Fehlerdetails, errorStack als Text für vollständigen Stack-Trace, userId als Foreign Key für ausführenden User und metadata als JSONB für zusätzliche Kontext-Informationen.

Die Snapshot-Erstellung erfolgt vor jedem Sync-Vorgang mit vollständiger Serialisierung des Entity-Zustands in beiden Systemen. Die Implementierung nutzt Deep-Cloning zur Vermeidung von Reference-Issues und JSON-Serialisierung für Persistierung. Die Snapshots umfassen alle relevanten Felder inklusive Metafields, Custom Fields und Relationen.

Die Revert-Funktionalität implementiert ein State-Restoration-System, das aus Snapshots den vorherigen Zustand wiederherstellt. Die Implementierung erstellt für jeden Revert-Vorgang einen neuen SyncLog-Eintrag mit status REVERTED und Referenz zum Original-Log. Die Revert-Logik unterscheidet zwischen verschiedenen Entitätstypen mit spezifischen Restoration-Strategien.

Für Product-Reverts werden Shopify productUpdate und ERPNext Item-Update-Operationen ausgeführt mit Daten aus dem sourceSnapshot. Die Implementierung berücksichtigt Varianten-Änderungen und Metafield-Updates. Für Customer-Reverts werden analog Shopify customerUpdate und ERPNext Customer-Update-Operationen durchgeführt mit vollständiger Address- und Contact-Restoration.

Für Order-Reverts ist zu beachten, dass bestimmte Operationen irreversibel sind wie Payment-Captures und Fulfillments. Die Revert-Logik implementiert daher partielle Reverts mit klarer Dokumentation nicht-revertierbarer Änderungen. Die Implementierung erstellt Compensating Transactions wo vollständige Reverts nicht möglich sind.

Das Admin-Dashboard für Logs implementiert Server-Side-Pagination mit Prisma gemäß [https://www.prisma.io/docs/concepts/components/prisma-client/pagination](https://www.prisma.io/docs/concepts/components/prisma-client/pagination). Die Filter-Optionen umfassen entityType, syncDirection, status, dateRange und userId mit kombinierbaren Filter-Bedingungen über Prisma where-Clauses. Die Implementierung nutzt Polaris DataTable Component gemäß [https://polaris.shopify.com/components/tables/data-table](https://polaris.shopify.com/components/tables/data-table) für die UI.

Die Search-Funktionalität implementiert Full-Text-Search über PostgreSQL-Trigram-Indizes gemäß [https://www.postgresql.org/docs/current/pgtrgm.html](https://www.postgresql.org/docs/current/pgtrgm.html) für Felder wie entityId, errorMessage und metadata. Die Implementierung nutzt Prisma raw queries für erweiterte PostgreSQL-Features.

Die Export-Funktionalität ermöglicht Download von Logs als CSV oder JSON mit Streaming für große Datenmengen. Die Implementierung nutzt Node.js Streams mit Transform-Streams für Formatierung und Compression mit zlib für große Exports.

Die Retention-Policy implementiert automatische Archivierung alter Logs mit konfigurierbare Aufbewahrungsfristen. Die Implementierung nutzt BullMQ Scheduled Jobs gemäß [https://docs.bullmq.io/guide/jobs/repeatable](https://docs.bullmq.io/guide/jobs/repeatable) für tägliche Cleanup-Tasks. Archivierte Logs werden in kostengünstigere Storage-Tiers verschoben oder in komprimierte Archive exportiert.

### Erfolgskriterien

Das Logging-System erfasst alle Sync-Operationen mit vollständigen Daten-Snapshots vor und nach dem Sync. Die SyncLog-Einträge enthalten ausreichende Informationen für vollständiges Tracing und Debugging. Die strukturierten Logs ermöglichen maschinelle Auswertung und Aggregation.

Das Admin-Dashboard zeigt Logs mit performanter Server-Side-Pagination und funktioniert bei großen Datenmengen ohne Performance-Degradation. Die Filter- und Search-Funktionalität ermöglicht schnelles Auffinden relevanter Log-Einträge. Die Full-Text-Search liefert Ergebnisse in akzeptabler Zeit auch bei Millionen von Log-Einträgen.

Die Revert-Funktionalität stellt erfolgreich den vorherigen Zustand für unterstützte Entitätstypen wieder her. Die Revert-Operationen erstellen korrekte SyncLog-Einträge mit Referenzen zu Original-Logs. Die Implementierung unterscheidet klar zwischen vollständig revertierbaren und partiell revertierbaren Operationen.

Die Export-Funktionalität generiert korrekte CSV- und JSON-Dateien mit allen Log-Informationen. Die Streaming-Implementierung verarbeitet große Exports ohne Memory-Issues. Die Retention-Policy archiviert alte Logs automatisch gemäß konfigurierter Fristen und hält die Datenbank-Größe überschaubar.

---

## Epic 7: Admin-Interface und granulare Konfigurationsoberfläche

### Technische Beschreibung

Dieses Epic implementiert das vollständige Admin-Interface als Embedded Shopify App unter ausschließlicher Verwendung von Shopify Polaris Components gemäß [https://polaris.shopify.com/components](https://polaris.shopify.com/components). Die Implementierung folgt den Shopify App Design Guidelines unter [https://shopify.dev/docs/apps/design-guidelines](https://shopify.dev/docs/apps/design-guidelines) und nutzt Shopify App Bridge für native Admin-Integration gemäß [https://shopify.dev/docs/api/app-bridge](https://shopify.dev/docs/api/app-bridge).
Die Navigation-Struktur nutzt den Polaris Navigation Component gemäß [https://polaris.shopify.com/components/navigation](https://polaris.shopify.com/components/navigation) mit Sections für Dashboard, Connections, Sync Configuration, Logs, Inventory Mappings und Settings. Die Implementierung folgt dem Multi-Page-Pattern mit React Router gemäß den Remix-Routing-Conventions unter [https://remix.run/docs/en/main/file-conventions/routes](https://remix.run/docs/en/main/file-conventions/routes).
Das Dashboard implementiert Key-Performance-Indicators mit Polaris Cards gemäß [https://polaris.shopify.com/components/layout-and-structure/card](https://polaris.shopify.com/components/layout-and-structure/card) und DisplayText für Metriken. Die angezeigten Metriken umfassen Total Syncs Today/Week/Month, Success Rate, Failed Syncs Requiring Attention, Average Sync Duration und Last Sync Timestamps per Entity Type. Die Daten-Aggregation erfolgt über Prisma-Aggregation-Queries gemäß [https://www.prisma.io/docs/concepts/components/prisma-client/aggregation-grouping-summarizing](https://www.prisma.io/docs/concepts/components/prisma-client/aggregation-grouping-summarizing).
Die Connections-Seite implementiert Formulare für Shopify- und ERPNext-Credentials mit Polaris Form Components gemäß [https://polaris.shopify.com/components/forms](https://polaris.shopify.com/components/forms). Die ERPNext-Connection-Form umfasst Felder für ERPNext-URL, API-Key und API-Secret mit Validation über Zod-Schemas. Die Implementierung testet die Verbindung über einen Test-Request zur ERPNext API mit Feedback über Polaris Banner Component bei Success oder Error

Die Sync-Configuration-Seite implementiert granulare Einstellungen pro Entitätstyp mit Polaris Layout-Components gemäß [https://polaris.shopify.com/components/layout-and-structure/layout](https://polaris.shopify.com/components/layout-and-structure/layout). Jeder Entitätstyp erhält eine eigene Card mit Polaris SettingToggle Component gemäß [https://polaris.shopify.com/components/actions/setting-toggle](https://polaris.shopify.com/components/actions/setting-toggle) für Aktivierung oder Deaktivierung der Synchronisation. Die Sync-Direction-Auswahl erfolgt über Polaris RadioButton Components gemäß [https://polaris.shopify.com/components/selection-and-input/radio-button](https://polaris.shopify.com/components/selection-and-input/radio-button) mit den Optionen Shopify zu ERPNext, ERPNext zu Shopify und bidirektional.

Das Field-Mapping-Interface nutzt Polaris ResourceList Component gemäß [https://polaris.shopify.com/components/lists/resource-list](https://polaris.shopify.com/components/lists/resource-list) für die Darstellung von Feld-Zuordnungen. Jedes Mapping-Item zeigt Shopify-Feld, ERPNext-Feld und optionale Transformation-Function mit Edit- und Delete-Actions. Die Erstellung neuer Mappings erfolgt über ein Modal mit Polaris Modal Component gemäß [https://polaris.shopify.com/components/overlays/modal](https://polaris.shopify.com/components/overlays/modal), das Polaris Select Components gemäß [https://polaris.shopify.com/components/selection-and-input/select](https://polaris.shopify.com/components/selection-and-input/select) für Feld-Auswahl und Polaris TextField Component gemäß [https://polaris.shopify.com/components/selection-and-input/text-field](https://polaris.shopify.com/components/selection-and-input/text-field) für optionale Transformation-Logic nutzt.

Die Inventory-Mappings-Seite implementiert eine dedizierte Oberfläche für Location-Warehouse-Zuordnungen mit Polaris IndexTable Component gemäß [https://polaris.shopify.com/components/tables/index-table](https://polaris.shopify.com/components/tables/index-table). Die Tabelle zeigt Shopify Location Name und ID, zugeordnetes ERPNext Warehouse, konfigurierte Sync-Direction mit Icons zur visuellen Differenzierung und Update-Frequency. Die Inline-Editing-Funktionalität nutzt Polaris InlineError Component gemäß [https://polaris.shopify.com/components/forms/inline-error](https://polaris.shopify.com/components/forms/inline-error) für Validation-Feedback.

Die Erstellung neuer Inventory-Mappings erfolgt über ein mehrstufiges Formular mit Polaris Autocomplete Component gemäß [https://polaris.shopify.com/components/selection-and-input/autocomplete](https://polaris.shopify.com/components/selection-and-input/autocomplete) für die Suche von Shopify Locations über die GraphQL API gemäß [https://shopify.dev/docs/api/admin-graphql/latest/objects/Location](https://shopify.dev/docs/api/admin-graphql/latest/objects/Location). Die ERPNext Warehouse-Auswahl lädt verfügbare Warehouses über die ERPNext API gemäß [https://docs.erpnext.com/docs/user/manual/en/stock/warehouse](https://docs.erpnext.com/docs/user/manual/en/stock/warehouse) und präsentiert diese in einem durchsuchbaren Select-Component.

Die Conflict-Resolution-Configuration nutzt Polaris ChoiceList Component gemäß [https://polaris.shopify.com/components/selection-and-input/choice-list](https://polaris.shopify.com/components/selection-and-input/choice-list) für die Auswahl zwischen Strategien wie Shopify gewinnt, ERPNext gewinnt, neuester Timestamp gewinnt und manuelle Review erforderlich. Die Implementierung zeigt kontextuelle Hilfe über Polaris Tooltip Component gemäß [https://polaris.shopify.com/components/overlays/tooltip](https://polaris.shopify.com/components/overlays/tooltip) zur Erklärung der verschiedenen Strategien.

Die Metafield-Mapping-Konfiguration implementiert ein Interface zur Definition von Zuordnungen zwischen Shopify Metafields und ERPNext Custom Fields. Die Implementierung lädt verfügbare Metafield-Definitions über die metafieldDefinitions Query gemäß [https://shopify.dev/docs/api/admin-graphql/latest/queries/metafieldDefinitions](https://shopify.dev/docs/api/admin-graphql/latest/queries/metafieldDefinitions) und zeigt diese in einem Polaris DataTable Component. Die ERPNext Custom Fields werden über die DocType-API gemäß [https://frappeframework.com/docs/user/en/api/rest#listing-documents](https://frappeframework.com/docs/user/en/api/rest#listing-documents) abgerufen mit Filtering auf Custom Fields.

Die Type-Conversion-Configuration ermöglicht Definition von Transformations-Regeln für verschiedene Datentyp-Kombinationen. Die Implementierung nutzt Polaris Stack Component gemäß [https://polaris.shopify.com/components/layout-and-structure/stack](https://polaris.shopify.com/components/layout-and-structure/stack) für horizontales Layout von Source-Type, Transformation und Target-Type. Die verfügbaren Transformations-Functions werden über ein Plugin-System bereitgestellt mit Auto-Complete-Suggestions basierend auf registrierten Transformers.

Die Logs-Seite implementiert die in Epic 6 beschriebene Funktionalität mit Polaris Filters Component gemäß [https://polaris.shopify.com/components/lists/filters](https://polaris.shopify.com/components/lists/filters) für erweiterte Filter-Optionen. Die Filter umfassen Applied Filters als Pills mit Clear-Actions, Quick-Filters für häufige Abfragen wie Failed Syncs Today und Pending Reverts sowie Saved Filter Presets die User-spezifisch persistiert werden. Die Implementierung nutzt Polaris IndexTable mit Bulk-Actions für Batch-Reverts und Exports.

Die Detail-Ansicht einzelner Sync-Logs erfolgt über ein Polaris Modal mit Tabs für Overview, Source Snapshot, Target Snapshot, Error Details und Related Logs. Die Snapshot-Darstellung nutzt JSON-Syntax-Highlighting mit einer Third-Party-Library wie react-json-view unter Beachtung der Shopify-App-Content-Security-Policy gemäß [https://shopify.dev/docs/apps/tools/app-bridge/content-security-policy](https://shopify.dev/docs/apps/tools/app-bridge/content-security-policy). Die Error-Details zeigen vollständigen Stack-Trace mit Code-Context über Polaris CalloutCard Component gemäß [https://polaris.shopify.com/components/feedback-indicators/callout-card](https://polaris.shopify.com/components/feedback-indicators/callout-card).

Die Revert-Aktion implementiert eine Confirmation-Modal mit klarer Darstellung der Konsequenzen über Polaris Banner Component mit kritischem Status. Die Implementierung zeigt welche Felder revertiert werden, welche Änderungen nicht revertierbar sind und warnt bei potenziellen Side-Effects. Die Ausführung des Reverts zeigt Progress über Polaris ProgressBar Component gemäß [https://polaris.shopify.com/components/feedback-indicators/progress-bar](https://polaris.shopify.com/components/feedback-indicators/progress-bar) mit Live-Updates über Server-Sent-Events oder Polling.

Die Settings-Seite implementiert globale Anwendungs-Einstellungen mit Sections für Webhook-Configuration, Retry-Policies, Notification-Settings und Data-Retention. Die Webhook-Configuration zeigt registrierte Webhooks mit Status-Indicators über Polaris Badge Component gemäß [https://polaris.shopify.com/components/feedback-indicators/badge](https://polaris.shopify.com/components/feedback-indicators/badge) und ermöglicht manuelle Re-Registration. Die Retry-Policies nutzen Polaris RangeSlider Component gemäß [https://polaris.shopify.com/components/selection-and-input/range-slider](https://polaris.shopify.com/components/selection-and-input/range-slider) für Konfiguration von Max-Retries und Backoff-Multipliers.

Die Notification-Settings implementieren Konfiguration von Email-Alerts für verschiedene Event-Types mit Polaris Checkbox Components. Die Implementierung unterstützt per-User-Notifications mit Opt-In über User-Profil-Settings. Die Email-Templates werden über ERPNext Email-System gemäß [https://frappeframework.com/docs/user/en/email](https://frappeframework.com/docs/user/en/email) versendet mit customizable Templates.

Die Help-Integration nutzt Shopify App Bridge TitleBar mit Help-Actions gemäß [https://shopify.dev/docs/api/app-bridge/previous-versions/actions/titlebar](https://shopify.dev/docs/api/app-bridge/previous-versions/actions/titlebar) zur Verlinkung auf externe Dokumentation. Die Implementierung inkludiert contextual Help-Texte über Polaris FooterHelp Component gemäß [https://polaris.shopify.com/components/feedback-indicators/footer-help](https://polaris.shopify.com/components/feedback-indicators/footer-help) auf relevanten Seiten mit Links zu spezifischen Dokumentations-Abschnitten.

Die Responsive-Design-Implementierung nutzt Polaris responsive Layout-Utilities gemäß [https://polaris.shopify.com/design/spacing](https://polaris.shopify.com/design/spacing) für adaptive Darstellung auf verschiedenen Viewport-Größen. Die Implementierung testet auf Desktop, Tablet und Mobile-Viewports unter Berücksichtigung der Shopify-Admin-Sidebar-Breite.

Die State-Management-Strategie nutzt Remix Loaders und Actions gemäß [https://remix.run/docs/en/main/discussion/data-flow](https://remix.run/docs/en/main/discussion/data-flow) für Server-Side-Data-Fetching und Mutations. Die Implementierung vermeidet clientseitiges State-Management wo möglich und nutzt Form-Submissions mit Progressive-Enhancement. Optimistic-Updates werden für kritische User-Interactions implementiert über useFetcher Hook gemäß [https://remix.run/docs/en/main/hooks/use-fetcher](https://remix.run/docs/en/main/hooks/use-fetcher).

Die Accessibility-Implementierung folgt den Polaris Accessibility-Guidelines gemäß [https://polaris.shopify.com/foundations/accessibility](https://polaris.shopify.com/foundations/accessibility) mit korrekten ARIA-Labels, Keyboard-Navigation-Support und Focus-Management. Die Implementierung testet mit Screen-Readers und Keyboard-Only-Navigation zur Sicherstellung WCAG 2.1 Level AA Compliance.

Die Performance-Optimierung nutzt Remix Resource Routes für API-Endpoints gemäß [https://remix.run/docs/en/main/guides/resource-routes](https://remix.run/docs/en/main/guides/resource-routes) und implementiert Caching-Strategies mit Cache-Control-Headers. Die Implementierung nutzt Polaris Lazy-Loading für schwere Components und Code-Splitting über dynamic imports.

### Erfolgskriterien

Das Admin-Interface rendert korrekt als Embedded Shopify App mit vollständiger Polaris-Component-Integration ohne custom CSS. Die Navigation funktioniert nahtlos zwischen allen Sections mit korrektem Browser-History-Management. Das Dashboard zeigt akkurate Echtzeit-Metriken mit automatischer Aktualisierung über definierte Intervalle.

Die Connections-Seite validiert Credentials erfolgreich mit klarem Feedback bei erfolgreicher oder fehlgeschlagener Verbindung. Die Sync-Configuration ermöglicht granulare Einstellungen pro Entitätstyp mit Persistence aller Konfigurationen in der Datenbank. Das Field-Mapping-Interface ermöglicht intuitive Erstellung und Verwaltung von Feld-Zuordnungen mit Validation gegen verfügbare Felder.

Die Inventory-Mappings-Seite zeigt alle konfigurierten Location-Warehouse-Zuordnungen mit Inline-Editing-Funktionalität. Die Conflict-Resolution-Settings werden korrekt angewendet bei tatsächlichen Sync-Konflikten. Die Metafield-Mapping-Configuration ermöglicht vollständige Kontrolle über Metafield-Synchronisation mit Type-Conversion-Support.

Die Logs-Seite lädt schnell mit performanter Pagination auch bei großen Datenmengen. Die Filter-Funktionalität liefert korrekte Ergebnisse mit schnellen Response-Zeiten. Die Detail-Ansicht zeigt vollständige Sync-Informationen mit formatierten JSON-Snapshots. Die Revert-Funktionalität führt korrekte State-Restoration durch mit klarer Bestätigung und Fehlerbehandlung.

Die Settings-Seite persistiert alle globalen Konfigurationen korrekt. Die Webhook-Status-Anzeige reflektiert den aktuellen Registrierungs-Status mit Möglichkeit zur manuellen Intervention. Die Notification-Settings senden Emails zuverlässig bei konfigurierten Events.

Die gesamte Anwendung funktioniert responsiv auf verschiedenen Viewport-Größen mit angemessener Layout-Anpassung. Die Accessibility-Features ermöglichen vollständige Bedienung mit Keyboard und Screen-Reader. Die Performance-Metriken zeigen schnelle Ladezeiten mit Lighthouse-Scores über 90 für Performance und Accessibility.

---

# Task-Ableitung und nächste Schritte

Mit diesen sieben technisch präzise definierten Epics liegt nun eine vollständige Grundlage für die Task-Ableitung vor. Im nächsten Schritt können aus jedem Epic konkrete User Stories und technische Tasks abgeleitet werden, die jeweils spezifische Implementierungs-Anweisungen für AI-gestützte Entwicklung mit Cursor AI enthalten.

Detaillierte Technische Details sind hier zu finden: 

[ERPNext ←→ Shopify Sync: Technische Definition](https://www.notion.so/ERPNext-Shopify-Sync-Technische-Definition-2b8951ec3d8881e4849dd3704a94a788?pvs=21)

Die Tasks werden dabei folgende Struktur aufweisen: eine eindeutige Task-ID mit Epic-Referenz, eine präzise Beschreibung der zu implementierenden Funktionalität, konkrete Acceptance-Criteria mit testbaren Bedingungen, technische Implementierungs-Hinweise mit Links zu relevanten Dokumentations-Abschnitten, Dependencies zu anderen Tasks sowie geschätzte Story-Points oder Time-Estimates.

Die Task-Definition wird so formuliert sein, dass sie direkt als Prompt für Cursor AI verwendet werden kann, mit explizitem Kontext zu verwendenden APIs, erwarteten Code-Strukturen und erforderlichen Tests. Dies stellt sicher, dass die AI-gestützte Entwicklung auf verlässlichen Informationen basiert und Halluzinationen minimiert werden.

## Epics

[Unbenannt](ERPNext%20Connector%20-%20bi-directional/Unbenannt%202ac951ec3d888097a1dcdec2c9551df9_Epics%20%5Ba3k%5D%20292951ec3d8881309f97000b48ef7431.csv)

## Projektaufgabe

[Tasks](ERPNext%20Connector%20-%20bi-directional/Tasks%202ac951ec3d8880988970e74b2dcaa20b.csv)